/*function pseudocodeWindow(width,height,minWidth,minHeight,maxWidth,maxHeight,pseudocode){
    let newWindowPseudo = new BrowserWindow({
        width: width,
        height: height,
        minHeight:minHeight,
        minWidth:minWidth,
        maxWidth:maxWidth,
        maxHeight:maxHeight,
        webPreferences: {
            plugins: true,
            nodeIntegration: false
        },
        autoHideMenuBar: true,
    });
    newWindowPseudo.loadURL(`data:text/html,
        <html>
            <head>
            <title> Псевдокод </title>
            <meta charset="UTF-8">
            </head>
            <body>
                ${encodeURIComponent(pseudocode)}
            </body>
        </html>
    `);

    newWindowPseudo.webContents.on('did-finish-load', () =>{
        newWindowPseudo.webContents.insertCSS(
            'html{font-size:2.15vw;color:navajowhite;display:flex;flex-direction: column;background-color: #232323;font-family: "Times New Roman", sans-serif;font-weight: 400;font-style: normal;}\n' +
            '\n' +
            '#quickSort{font-size: 3vw}'
        );
    });

    newWindowPseudo.show();

    newWindowPseudo.on('closed', function () {
        newWindowPseudo = null;
    });

}*/

/*
ipcMain.on("btnMerge", function (event, arg) {
    pseudocodeWindow(500,500,500,500,500,500,` <pre>
    функція mergesort(matrix):
        якщо matrix.length > 1
            то
                mid := matrix.length // 2
                left_half := matrix[:mid]
                right_half := matrix[mid:

            mergesort(left_half)
            mergesort(right_half)

            i := j := k := 0

            поки i < left_half.length() та j < right_half.length()
                повторити
                    якщо left_half[i] < right_half[j]
                        то
                            matrix[k] := left_half[i]
                            i += 1
                        інакше
                            matrix[k] := right_half[j]
                            j += 1
                            k += 1
            поки i < left_half.length()
                повторити
                matrix[k] := left_half[i]
                i += 1
                k += 1

            поки j < right_half.length()
                повторити
                    matrix[k] := right_half[j]
                    j += 1
                    k += 1
        кінець якщо
        кінець функції
                </pre>`);
});

// create new window with pseudocode of Quick
ipcMain.on("btnQuick", function (event, arg) {
    pseudocodeWindow(400,400,400,400,400,400,`    <pre id="quickSort">
function розділити(arr, мін, макс) {
     опорний_елемент = arr[макс];

     i = мін - 1;

    для (j = мін; j <= макс - 1; j++) {
        якщо (arr[j] < опорний_елемент) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    [arr[i + 1], arr[макс]] = [arr[макс], arr[i + 1]];
    повернути i + 1;
}

function Швидке_сортування(arr, мін, макс) {
    якщо (мін < макс) {
        pi = розділити(arr, мін, макс);
        Швидке_сортування(arr, мін, pi - 1);
        Швидке_сортування(arr, pi + 1, макс);
    }
}
    </pre>`);
});

// create new window with pseudocode of Intro
ipcMain.on("btnIntro", function (event, arg) {
    pseudocodeWindow(600,600,600,600,600,600,`<pre id="introSort">
    процедура introsort(A: масив, максглибина):
        n ← довжина(A)
        якщо n < 16 тоді:
            сортуваннявставками(A)
        інакше якщо максглибина = 0 тоді:
            heapsort(A)
        інакше:
            p ← partition(A)
            introsort(A[1:p-1], максглибина - 1)
            introsort(A[p+1:n], максглибина - 1)

    процедура сортуваннявставками(A: масив):
        для i від 1 до довжина(A) - 1 крок 1 робити:
            поточний ← A[i]
            j ← i - 1
        поки j >= 0 і A[j] > поточний робити:
            A[j + 1] ← A[j]
            j ← j - 1
        A[j + 1] ← поточний

    процедура heapsort(A: масив):
        heapify(A)
        для i від довжина(A) - 1 до 0 крок -1 робити:
            обмін A[0] з A[i]
            siftDown(A, 0, i - 1)

    процедура heapify(A: масив):
        n ← довжина(A)
        для i від n / 2 - 1 до 0 крок -1 робити:
            siftDown(A, i, n - 1)

    процедура siftDown(A: масив, початок, кінець):
        корінь ← початок
        поки корінь * 2 + 1 ≤ кінець робити:
            дитина ← корінь * 2 + 1
            обмін ← корінь
            якщо A[обмін] < A[дитина] тоді:
                обмін ← дитина
            якщо дитина + 1 ≤ кінець і A[обмін] < A[дитина + 1] тоді:
                обмін ← дитина + 1
            якщо обмін = корінь тоді:
                повернути
            інакше:
                обмін A[корінь] з A[обмін]
                корінь ← обмін
                </pre>`);
});
*/